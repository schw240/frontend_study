<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        /* * {
            margin: 0;
            padding: 0;
            border: 0;
        } */
        /* #root p {
            color: white;
            font-size: 20px;
            background-color: green;
            text-align: center;
            width: 200px;
        } */
        /* #btn_plus {
            background-color: red;
            border: 2px solid #000;
            font-size: 15px;
            width: 200px;
        } */
    </style>
</head>
<body>
    <div id="root"></div>
    
    <!-- <button id="btn_plus">+</button> -->
    <!-- 리액트 cdn -->
    <script crossorigin src="https://unpkg.com/react@17/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@17/umd/react-dom.development.js"></script>
    <!-- <script type="text/javascript">
        // console.log(React)
        // console.log(ReactDOM)

        // const root = document.querySelector('#root');
        // const btn_plus = document.querySelector('#btn_plus');

        // let i = 0;

        // root.innerHTML = `<p>init: 0</p>`;

        // btn_plus.addEventListener('click', () => {
        //     root.innerHTML = `<p>init : ${++i}</p>`;
        // });

    //    const component = {
    //        message: "init",
    //        count: 0,
    //        render() {
    //            return `<p>${this.message} : ${this.count}</p>`;
    //        }
    //    }

    //    function render(rootElement, component) {
    //        rootElement.innerHTML = component.render();
    //    }

    //    // 초기화
    //    // 여기서 render함수는 컴포넌트를 html로 바꾸어 브라우저에 나타나게 하는것
    //    // 클래스기반 리액트는 render함수를 반드시 호출해야함 
    //    render(document.querySelector("#root"), component);

    //    document.querySelector('#btn_plus').addEventListener('click', () => {
    //        component.message = 'update';
    //        component.count = component.count + 1;

    //        render(document.querySelector("#root"), component);
    //    })


    // 리액트 사용

    
    const Component = props => {
        // 인자, 첫번째 -> 태그
        // 두번째 -> 외부에서 넣는 값들 ex) <p hello="world">
        // 세번째 -> <p>""</p> 내용
        return React.createElement('p', null, `${props.message} : ${props.count}`)
    }

    ReactDOM.render(/* 리액트 컴포넌트 */ React.createElement(Component, {message: 'init', count: 0}, null), document.querySelector('#root'))

    document.querySelector('#btn_plus').addEventListener('click', () => {
        ReactDOM.render(
            React.createElement(
                Component,
                { message: "update", count: 10 },
                null
            ),
            document.querySelector("#root")
        )
    })
    </script> -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="text/babel">
        console.log(React)
        console.log(ReactDOM)

        // // 정의 클래스형
        // class ClassComponent extends React.Component {
        //     render() {
        //         return <div>Hello</div>;
        //     }
        // }

        // // 사용
        // ReactDOM.render(
        //     <ClassComponent />,
        //     document.querySelector('#root')
        // )

        // 함수형 정의 1
        // function FunctionComponent() {
        //     return <div>Hello</div>;
        // }

        // 정의 2 화살표 함수방식, return문이 한개이면 리턴문 생략 가능
        // const FunctionComponent = () => <div>Hello</div>
        

        // 사용
        // ReactDOM.render(<FunctionComponent />, document.querySelector('#root'))

        // React.createElement(
        //     type, //태그 이름 문자열 | 리액트 컴포넌트 | React.Fragment
        //     [props], //리액트 컴포넌트에 넣어주는 데이터 객체
        //     [...children] //자식으로 넣어주는 요소
        // )

        // 1. 태그 이름 문자열 type
        // <h1>type 이 "태그 이름 문자열" 입니다.</h1>
        // ReactDOM.render(
        //     React.createElement('h1', null, `type이 태그 이름 문자열 입니다.`),
        //     // 실제 돔에 그리는것
        //     document.querySelector('#root')
        // )

        // 2. 리액트 컴포넌트 type

        // const Component = () => {
        //     return React.createElement('p', null, `type이 "React 컴포넌트" 입니다.`)
        // }

        // // <Component></Component> => <Component /> => <p>type이 "React 컴포넌트" 입니다.</p>
        // ReactDOM.render(
        //     React.createElement(Component, null, null),
        //     document.querySelector('#root')
        // )

        // 3. React.Fragment
        // Fragment가 없없을 때는 무조건 태그하나를 만들고 그 안에 표현을 해야했지만
        // Fragment 이후 바로 요소를 선택해 태그 없이도 자식을 표현할 수 있음
        // ReactDOM.render(
        //     React.createElement(
        //         React.Fragment,
        //         null,
        //         `type 이 "React Fragment" 입니다.`,
        //         `type 이 "React Fragment" 입니다.`,
        //         `type 이 "React Fragment" 입니다.`
        //     ),
        //     document.querySelector('#root')
        // )

        // 4. 복잡한 엘리먼트의 모임
        // <div>
        //     <div>
        //         <h1>주제</h1>
        //         <ul>
        //             <li>React</li>
        //             <li>Vue</li>
        //         </ul>
        //     </div>
        // </div>

        // ReactDOM.render(
        //     React.createElement(
        //         "div", 
        //         null, 
        //         React.createElement(
        //             "div",
        //              null, 
        //              React.createElement("h1", null, "주제"),
        //              React.createElement(
        //                 "ul", 
        //                 null,
        //                 React.createElement("li", null, "React"),
        //                 React.createElement("li", null, "Vue"),
        //              )
        //          )
        //     ),
        //     document.querySelector("#root")
        // )


        // babel이란 우리가 작성한 코드를(JSX문법) 순수하게 실행할 수 있는 자바스크립트로 바꿔주는 역할
        // 아래의 코드는 지금 자바스크립트로 바꿔주는 과정을 사용하고 있지 않음
        // 직접 html 코드를 작성해서 사용하는 방식

        // JSX란 HTML문법을 JavaScript 코드 내부에 작성한 것(JavaScript eXtension)
        // React에서 HTML을 표현할 때 JSX를 사용하며 빌드시 Babel에 의해 자바스크립트로 변환된다.
        
        // 아래와 같은 방식으로 props처럼 들어감
        // {a: "a"}
        // ReactDOM.render(
        //     // 맨 처음 타입이 div태그
        //     //  그 다음부터 children
        //     // 만약 attribute를 사용한다면 props처럼 들어가게 됨
        //     <div a="a">
        //         <div>
        //             <h1>주제</h1>
        //             <ul>
        //                 <li>React</li>
        //                 <li>Vue</li>
        //             </ul>
        //         </div>
        //     </div>,
        //     document.querySelector("#root")
        // );
        // JSX를 사용하는 방법은 가독성이 매우 뛰어나기 때문
        // JSX문법은 최상위 요소는 무조건 하나
        // 이것때문에 맨 위에 div 태그로 감싸주거나 <>자식들</>로 감싸줌
        // 최상위 요소 리턴하는 경우 ()로 감싸기
        // 자식들을 바로 랜더링 하고 싶으면 <>자식들</> 사용 -> Fragment
        // 자바스크립트 표현식을 사용하려면 {표현식}를 이용
        // if 문 사용 불가, 삼항연산자 혹은 && 사용
        // style을 이용해 인라인 스타일링 가능
        // class대신 className을 사용해 class 적용가능
        // 자식요소가 있으면 꼭 닫아야 하고, 자식요소가 없으면 열면서 닫기
        // ex) <p>내용</p>
        // <br />
        


        // props와 state
        // props는 컴포넌트 외부에서 컴포넌트에게 주는 데이터
        // state는 컴포넌트 내부에서 변경할 수 있는 데이터
        // 둘다 변경 발생시 렌더가 다시 일어날 수 있다

        // render함수
        // Props와 State를 바탕으로 컴포넌트를 그림
        // 그리고 Props와 State가 변경되면 컴포넌트를 다시 그림
        // 컴포넌트를 그리는 방법을 기술하는 함수가 Render 함수


        // 함수형
        // function Component(props) {
        //     return (
        //         <div>
        //             <h1>{props.message} 이것은 함수로 만든 컴포넌트 입니다.</h1>
        //         </div>
        //     )
        // }


        // 클래스형
        // 클래스형은 this를 붙여주기
        // class Component extends React.Component {
        //     // State값 항상 객체형식으로 사용
        //     // state = {
        //     //     count: 0,
        //     // }

        //     // 상태값을 변경할 수 있는 다른 방식
        //     constructor(props) {
        //         // 리액트 컴포넌트의 생성자 함수를 상속
        //         super(props);
        //         this.state = { count: 0 };
        //     }

        //     render() {
        //         return (
        //             <div>
        //                 <h1>{this.props.message} 이것은 클래스로 만든 컴포넌트 입니다.</h1>
        //                 <p>{this.state.count}</p>
        //             </div>
        //         )
        //     }


        //     // render가 끝난이후 state 변경 Lifecycle
        //     componentDidMount() {
        //         setTimeout(() => {
        //             // 아래와 같이 작성하면 될거같지만 안됨 렌더링 이후 상태값 변경할때 리액트는 밑에와 다른 방식 사용
        //             // this.state.count = this.state.count + 1;
                    
        //             // 리액트 방식1
        //             // this.setState({
        //             //     count: this.state.count + 1,
        //             // });
        //             // 리액트 방식 2
        //             // 앞에 값을 이용할 수 있다는 장점이 있다.
        //             this.setState((previousState) => {
        //                 const newState = { count: previousState.count + 1 };
        //                 return newState;
        //             })
        //         }, 1000);
        //     }

        //     // 방법 2 클래스형만 사용 가능
        //     static defaultProps = {
        //         message: "기본값2"
        //     }
        // }


        // 디폴트 메세지 기능 사용해보기 방법1 함수형도 사용 가능
        // Component.defaultProps = {
        //     message: '기본값',
        // }
        
        // ReactDOM.render(
        //     // <Component />,
        //     <Component message="기본값 아닌 경우!!!" />,
        //     document.querySelector("#root")
        // );


        // Event Handling
        // HTML DOM에 이벤트 발생시 그에 걸맞는 변경이 이루어나도록 해주기
        // JSX에 이벤트 설정 가능
        // Event Handling은 camelCase형식으로만 사용할 수 있음 ex) onClick, onMouseEnter
        // 이벤트에 연결된 자바스크립트 코드는 함수임 이벤트={함수} 방식으로 사용
        // 실제 DOM 요소들에게만 사용 가능
        // 리액트 컴포넌트에 사용하면 그냥 porps로 전달함

        // function Component() {
            // return (
            //     <div>
            //         <button onClick={() => {
            //             console.log("clicked");
            //         }}
            //         > 클릭 
            //         </button>
            //     </div>
            // )
        // }

        class Component extends React.Component {
            state = {
                count: 0,
            }
            // constructor(props) {
            //     super(props)
            //     // bind를 해주어야 이벤트 핸들링 함수 바인딩
            //     this.click = this.click.bind(this)
            // }

            render() {
                return (
                    <div>
                        <p>{this.state.count}</p>
                        <button onClick={this.click}>클릭</button>
                    </div>
                )
            }
            // 바인딩 방법2 화살표 함수로 만들기
            click = () => {
                console.log("clicked");
                this.setState((state) => ({
                    ...state,
                    count: state.count + 1,
                }));
            }
        }

        ReactDOM.render(<Component />, document.querySelector("#root"))
    </script>   
</body>
</html>